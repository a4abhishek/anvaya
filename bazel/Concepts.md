# Bazel Concepts: The Deep Dive

> **The Anvaya:** *To master the spell, you must understand the physics of the magic.*

---

## **<a id="workspace"></a>Workspace**
>
> The root directory containing a `MODULE.bazel` file, defining the project boundary.

In most systems (git, npm), the root is implicit. In Bazel, it is explicit and absolute. The Workspace is the "Event Horizon" of your build. Nothing outside it exists unless explicitly fetched via `MODULE.bazel`.

**Why it matters:**
This is why you can't just `import "../../../other-project/lib"`. If it's not in the Workspace (or a defined external repo), it's invisible. This constraint forces architectural discipline.

## **<a id="package"></a>Package**
>
> A directory containing a `BUILD` file.

In most build systems, every folder is a package. In Bazel, a folder is just a folder *until* you drop a `BUILD.bazel` file in it. This file is the "border control" that defines what files in this directory are visible to the build graph.

Think of the filesystem as a flat plain. Dropping a `BUILD` file creates a "City" (Package).

* **Subdirectories:** Are just neighborhoods *inside* that city, unless they have their own `BUILD` file.
* **Boundary:** A Package encapsulates its sources. `srcs = glob(["**/*.go"])` stops at the boundary of sub-packages.

**The "Fine-Grained" Trade-off:**

* **Too few packages (Monolith):** One `BUILD` file for 1000 files. Easy to write, but changing one file rebuilds everything.
* **Too many packages (Micro):** One `BUILD` file per file. Maximum caching, but huge RAM overhead for the graph.
* **Sweet Spot:** One Package per logical library (e.g., Go package).

---

## **<a id="target"></a>Target**
>
> An addressable item in the build graph (e.g., `//pkg:name`).

Targets are the nodes in the Directed Acyclic Graph (DAG).

* **Input Targets:** Source files (leaves of the graph).
* **Output Targets:** Rules (intermediary nodes).

**Crucial Mental Model:**
Bazel doesn't build *files*; it builds *targets*. If a file exists on disk but isn't listed in a Target's `srcs`, Bazel will ignore it even if it's right next to `main.go`.

---

## **<a id="rule"></a>Rule**
>
> The logic (recipe) written in Starlark to build a Target.

A Rule is a function that transforms the **Analysis Phase** (thinking) into the **Execution Phase** (doing).

* **Analysis:** "I see `go_library`. I need to generate a compile command."
* **Execution:** "Running `go tool compile ...`".

**Interesting Nuance:**
You can write your own rules! Want to compile `.docx` to `.pdf`? You can write a rule that defines the inputs, the tool (LibreOffice), and the command. This makes Bazel truly language-agnostic.

---

## **<a id="starlark"></a>Starlark**
>
> The Python-like configuration language used for `BUILD` and `.bzl` files.

It looks like Python, but it's lobotomized for your safety.

* **No Recursion:** Prevents infinite loops in build graph calculation.
* **No Side Effects:** Can't read files (except via rules), can't check the time (`import time` fails), can't access the network.
* **Frozen:** Once a variable is defined in a generic function, it is immutable.

**Why?**
This guarantees **Determinism**. Evaluating the same `BUILD` file on Monday and Friday *must* yield the exact same graph.

---

## **<a id="label"></a>Label**
>
> The unique coordinate ID of a Target (`//pkg:name`).

The coordinate system of the Bazel Universe.

* `@repo//path/package:target`
  * `@repo`: The external repository (default is main workspace `@@`).
  * `//`: The root of that repo.
  * `path/package`: The directory path.
  * `:target`: The name in `BUILD`.

**Pro Tip:**
Relative labels (`:logger`) work inside the same `BUILD` file. Absolute labels (`//backend/logger:logger`) work everywhere.

---

## **<a id="action"></a>Action**
>
> A single command execution (compile, link, zip) generated by a Rule.

The "Atom" of the build.

* **Phase 1 (Loading):** Read BUILD files.
* **Phase 2 (Analysis):** Rules generate a list of Actions (The Action Graph).
* **Phase 3 (Execution):** Bazel checks the cache. If `hash(inputs) + hash(command)` matches, it skips the Action. If not, it runs it.

**Why it matters:**
This is why Bazel is fast. It doesn't just check file timestamps (like Make); it checks content hashes of the entire action definition.

---

## **<a id="hermetic"></a>Hermeticity**
>
> A build that relies *only* on declared inputs and toolchains, never on the host system.

**The Reality:**
The "Clean Room" philosophy. A perfectly hermetic build is completely isolated from the host OS. It does not see `/usr/bin`, `/etc`, or your system environment variables (`PATH`, `JAVA_HOME`).

**Why it matters:**

* **Eliminates "It works on my machine":** If the build doesn't depend on your machine's configuration, it works everywhere.
* **Enables Remote Caching:** If the build is hermetic, the output from a CI machine can be safely reused on your laptop.

**The Fix:**
Use **[Toolchains](#toolchain)**. Instead of using the system's `gcc` or `python`, Bazel downloads its own version-locked toolchain.

---

## **<a id="sandbox"></a>Sandbox**
>
> An isolated directory where an Action executes, containing only declared inputs.

**The Mechanics:**

1. Bazel creates `/tmp/bazel-sandbox/123/`.
2. It creates **symbolic links (symlinks)** to only the source files listed in `srcs` and `deps`.
3. It creates a user namespace (on Linux) to block access to `/home`, `/usr`, and `/etc`.
4. It runs the compiler (or linker) inside this prison.

**The Benefit:**
If you forgot to add a library to `deps`, the compiler literally cannot see the header files. The error happens *now*, not in production.

---

## **<a id="toolchain"></a>Toolchain**
>
> A set of tools (compilers, linkers) downloaded by Bazel, independent of the host OS.

A Toolchain is just another dependency.

* **Old Way:** "Install Go 1.22 on all CI agents." (Drift is inevitable).
* **Bazel Way:** "The build depends on `@go_sdk`." Bazel fetches the compiler binaries for the current OS (Mac/Linux/Windows) just-in-time.

---

## **<a id="diamond-dependency"></a>Diamond Dependency**
>
> The conflict when two dependencies rely on different versions of a third dependency.

**The Scenario:**

* **Project A** depends on **Lib B** and **Lib C**.
* **Lib B** needs **Logger v1.0**.
* **Lib C** needs **Logger v2.0**.
* **The Shape:** Draw lines from A to B/C, then from B/C to Logger. It looks like a diamond.

**The Hell:**
In legacy systems (WORKSPACE), Bazel sees two conflicting requests for "Logger" and panics (or silently picks the first one). You, the human, must manually intervene and "pin" a version, often breaking one of the libraries. This manual toil is "Diamond Dependency Hell."

---

## **<a id="mvs"></a>Minimal Version Selection (MVS)**
>
> The algorithm that picks the oldest version that satisfies all constraints (i.e., the "max of the mins").

**The Logic:**

* **Lib A** needs `v1.2` (or higher).
* **Lib B** needs `v1.5` (or higher).
* **Valid Set:** `v1.5`, `v1.6`, `v1.7`...
* **MVS Decision:** Picks **v1.5**. It is the *minimum* version that satisfies everyone.
* **The Philosophy:** It **minimizes the distance from the requirement**; it doesn't pick `v1.6` simply because it's available.

**Why it matters:**

* **vs. "Latest" (npm/Cargo):** Other systems might see `v1.6` in the registry and pick it to give you "fresh" code. MVS ignores `v1.6` because no one *asked* for it.
* **Stability:** Your build never changes just because a new version was published. It only changes when you explicitly upgrade a dependency requirement.

---

## **<a id="bzlmod"></a>Bzlmod**
>
> The modern external dependency management system (Bazel 7+).

Finally, a package manager!

* **Registry:** Uses the Bazel Central Registry (BCR) (like npmjs.org).
* **Resolution:** Solves the **[Diamond Dependency](#diamond-dependency)** problem using **[Minimal Version Selection (MVS)](#mvs)** to mathematically pick a single valid version for the entire graph.
* **Transitivity:** You no longer need to copy-paste the transitive dependencies of your dependencies into your WORKSPACE.

---

## **<a id="bazelisk"></a>Bazelisk**
>
> A wrapper for Bazel that downloads the correct version specified in `.bazelversion`.

**The Reality:**
A perfect example of the Unix philosophy: "Do one thing well."

* **Multi-Arch:** Automatically detects if you are on Mac ARM64, Linux AMD64, or Windows and fetches the correct binary.
* **Channels:** Supports dynamic versions like `latest`, `7.x`, or `last_green` in addition to strict pins like `7.1.0`.
* **Seamless:** You rename it to `bazel` and forget it exists. It ensures your entire team is bit-wise identical without a manual install step.
